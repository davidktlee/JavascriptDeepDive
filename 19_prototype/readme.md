# 19장 프로토타입

# 19장 프로토타입

자바스크립트는  명령형, 함수형, 프로트타입 기반, 객체지향 프로그래밍을 지원하는 멀티 패러다임 언어

자바스크립트를 이루고 있는 거의 **“모든 것"이 객체**

1. 객체 지향 프로그래밍
    1. 객체의 집함으로 프로그램을 표현하는 프로그래밍 패러다임
    2. 실체를 인식하는 철학적 사고를 프로그래밍이에 접목하려는 시도, 실체는 속성을 가지고 있음
    3. 프로그램엑서 필요한 속성만 간추려 내어 표현하는 것을 추상화
    4. 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조를 객체
        1. 객체의 상태 데이터를 프로퍼티
        2. 동작을 메서드라 함
2. 상속과 프로토타입
    1. 상속은 객체지향 프래그래밍 핵심 개념
    2. 자바스크립트는 프로토타입 기반으로 상속 구현
    3. 생성자 함수로 객체 생성시 메서드를 중복 소유하는 문제


        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/419f759c-5796-4058-8eec-a80cc9a70422/Untitled.png)
        
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67426334-e0c8-4677-811d-e11af8f8d6c8/Untitled.png)

3. 프로토타입 객체
    1. 객체간 상속을 구현하기 위해 사용
        1. 프로토타입은 부모 객체가 자식 객체에 공유 프로퍼티(메서드)를 제공
        2. 상속받은 객체는 부모 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용
    2. `__proto__`접근자 프로퍼티
        1. 모든 객체는 __ proto __ 접근자 프로퍼티를 통해 자신의 프로토타입 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근
        2. `__proto__` 접근자 프로퍼티
            1. 내부슬롯은 값이 아니지만 접근자를 통해 접근 가능
        3. `__proto__`ㄴ접근자 프로퍼티는 상속을 통해 사용
            1. `__proto__`객체가 직접 소유하는 프로퍼티가 아닌 Object.prototype의 프로퍼티
        4. `__proto__`접근자 프로퍼티를 통해 프로토타입에 접근하는 이유
            1. 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지
            2. 프토타입 체인은 단방향 링크드 리스트로 구현되어야 함

           ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d71853b-afc3-416f-82c1-0ba5a84a9aff/Untitled.png)

        5. `__proto__` 접근자 프로퍼티를 코드 내에 직접 사용하는 것은 권장하지 않음
            1. ES5까지 비표준, ES6에서 표준
            2. 모든 객체가 사용하는 것이 아니기 때문에 비권장
            3. Object.create(null)로 생성 시에는 `undefined`
            4. 확인 시 Object.getPrototypeOf, 교체 시 Object.setPrototypeOf
    3. 함수 객체의 prototype 프로퍼티
        1. 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴
    4. 프로토타입의 constructor 프로퍼티와 생성자 함수
        1. 모든 프로토타입은 contructor 프로퍼티를 갖음
4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
    1. 리터럴 표기법에 의해 생성된 객체는 OrdinaryObjectCreate를 호출하여 빈 객체를 생성, Object 생성자 함수가 생성한 객체는 아니다
    2. 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 가짐
    3. 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재
5. 프로토타입 생성 시점
    1. 생성자 함수가 생성되는 시점에 생성
    2. 사용자 정의 생성자 함수
        1. constructror 갖는 함수 객체
        2. 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 생성
        3. 생성자 함수로 호출할 수 없는 함수는 생성되지 않음(화살표 함수 등)
    3. 빌트인 생성자 함수
        1. Object, String, Number,,,,
        2. 전역 객체가 생성되는 시점
6. 객체 생성 방식과 프로토타입의 결정
    1. 객체 생성 방식
        1. 객체 리터럴
        2. Object 생성자 함수
        3. 생성자 함수
        4. Object.create 메서드
        5. 클래스
    2. 추상연산 OrdinaryObjectCrate에 의해 생성되는 공통점
        1. 객체 리터럴
            1. 자바스크립트 엔진에서 전달하는 프로토타입은 Object.prototype
        2. Object 생성자 함수
            1. 자바스크립트 엔진에서 전달하는 프로토타입은 Object.prototype
        3. 생성자 함수
            1. 생성자 함수의 prototype 프로퍼티에 바인되어 있는 객체
7. 프로토타입 체인

   ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e87f329-8d17-4c35-92f0-b482789e3343/Untitled.png)

    1. 객체의 프로퍼티에 접근할 때 프로퍼티가 없다면 부모 프로퍼티를 순차적으로 검색, 프로토타입은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘
    2. 프로토타입 체인 최상위는 언제나 Object.prototype
    3. 프로퍼티를 검색 할 수 없는 경우 undefined 반환, 에러 나지 않음
8. 오버라이딩과 프로퍼티 섀도잉
    1. 프로토타입이 소유한 프로퍼티를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티
    2. 인스턴스 프로퍼티에 프로타입의 프로퍼티를 추가하면 프로토타입의 프러퍼티가 수정되지 않고 인스턴스 프러퍼티에 추가되고 이것을 오버라이딩이라 한다.
    3. 이처럼 상속 관계의 프로퍼티가 가져지는 현상을 프로퍼티 섀도잉이라 함

   ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9ee5b3ad-4d6a-48e3-93b3-1e36c04175a4/Untitled.png)

9. 프로토타입 교체
    1. 생성자 함수, 인스턴스에 의해 교체
    2. 생성자 함수
        1. 생성자 함수의 prototype 프로퍼티를 교체
    3. 인스턴스
        1. Object.setPrototypeOf로 교체
    4. 프로토타입 교체를 통해 상속 관계를 동적으로 변경하는 것은 번거로움, 직접 상속이 편리하고 안전
10. instanceof 연산자
    1. 좌변에 객체 식별자 우변에 생성자 함수
    2. 우변 생서장 함수 prototype에 바인딩된 객체가 좌변 객체 프로토타입 체인 상에 존재하면 true 아니면 false
11. 직접 상속
    1. Object.create
        1. 첫번째 매개변수: 생성할 객체의 프로토타입을 지정
        2. 두번째 매개변수: 프로퍼티키와 디스크립터 객체
        3. 장점
            1. new 연산자 없이
            2. 프로토타입을 지정하여 객체 생성
            3. 객체 리터럴에 의해 생성된 객체도 상속 가능
    2. 객체 리터럴 내부에서 `__proto__`의한 직접 상속
12. 정적 프로퍼티/메서드
    1. 생성자 함수도 객체 이므로 자신의 프로퍼티, 메서드를 소유 가능
    2. 이를 정적 프로퍼티 / 메서드라 함
    3. 생성한 인스턴스에서 참조, 호출 불가능
13. 프로퍼티 존재 확인
    1. in 연산자
        1. 객체 내에 특정 프로퍼티가 존재하는지 확인
        2. 상속받은 프로퍼티도 true
        3. ES6에서 추가된 Reflect.has 메서드도 동일한 동작
    2. Object.prototype.hasOwnProperty 메서드
        1. 상속받은 프로토타입의 프로퍼티 일 경우 false반환
14. 프로퍼티 열거
    1. for … in
        1. 객체의 모든 프로퍼티를 순회하며 열거
        2. 상속받은 프로퍼티까지 열거
        3. 열거가 불가능한 [[Enumerable]] false는 제외
    2. Object.keys, value, entries 메서드
        1. 객체 자신의 프로퍼티만 확인시 권장
        2. Object.keys는 프로퍼티 key를 배열로 반환
        3. Object.values는 값을 배열로
        4. Object.entries는 키와 값의 쌍을 배열로
