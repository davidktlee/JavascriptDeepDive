### 객체 리터럴

## 객체란

- 자바스크립트는 객체 기반의 프로그래밍 언어이다.
- 원시값을 제외한 거의 모든 것이 객체다.
- 원시타입은 단 하나의 값만 나타내지만 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조다.
- 원시타입의 값, 즉 원시값은 변경이 불가능하지만 객체타잆의 값, 즉 객체는 변경이 가능한 값이다.
- 11장에서 자세히

- 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.

- 자바스크립트에서 사용할 수 있는 모든값은 프로퍼티 값이 될 수 있다.
- 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다.
- 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부른다.

  - 프로퍼티 : 객체의 상태를 나타내는 값
  - 메서드　 : 프로퍼티를 참조하고 조작할 수 있는 동작

- 객체는 프로퍼티와 메서드를 모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.

# 객체와 함수

- 자바스크립트의 객체는 함수와 밀접한 관계를 가진다.
- 함수로 객체생성을 하기도 하며, 함수 자체가 객체이기도 하다.
- 객체를 이해해야 함수를 이해할 수 있고, 반대의 경우도 마찬가지이다.
- 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 객체지향 프로그래밍이라고 한다.
- 19.1절에서 자세히

## 객체 리터럴에 의한 객체 생성

- 클래스 기반 객체지향 언어(java, C++ 등)는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체 생성

  # 인스턴스

  - 클래스에 의해 생성되어 메모리에 저장된 실체를 말함.
  - 객체지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념
  - 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 함
  - 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어

- 객체를 생성하는 방법은 다음과 같다.

  - 객체 리터럴
  - object 생성자 함수
  - 생성자 함수
  - object.create 메서드
  - 클래스

- 객체 리터럴은 {} 내에 0개 이상의 프로퍼티를 정의한다.
- 할당되는 시점에 js 엔진은 객체 리터럴을 해석해 객체를 생성한다.
- {} 내에 아무것도 없으면 빈 객체가 생성된다.
- 빈 객체도 객체에 포함된다(empty = {}; typeof empty; // object)
- 객체 리터럴의 중괄호는 코드블럭을 의미하지 않는다.

- js의 유연함과 강력함을 대표하는 객체 생성방식이다.
- 일반적인 변수 선언과 같은 방법으로 객체를 정의한다.

# 프로퍼티

- 객체는 프로퍼티의 집합이다.
- 프로퍼티는 key 와 value 로 구성된다.
- 프로퍼티 나열은 , 로 구분한다.
- 프로퍼티의 key는 전부 string(문자열)이므로 "" 또는 '' 로 묶어야한다.

  - 식별자 네이밍 규칙을 준수하는 이름이라면 "" 또는 '' 를 생략해도 된다.
  - ex) const name = {firstName :"kim", "last-name" : "garam"};
  - 해당 규칙을 지키지 않는다면 syntaxError 를 리턴한다.

- 문자열 또는 문자열로 표현할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다.
- 이 때는 []로 묶어야 한다.
- ex) const obj = {}; const key = "hello"; obj[key] = "world";

- 중복 선언하거나, 이미 정의된 프로퍼티를 다시 정의한다면 나중에 선언된 값이 덮어쓰게 된다.
- var, const, let 등의 예약어도 key로 생성될 수는 있으나, 사용하지 않음을 권장한다.
- 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다.
- 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 반환된다고 한다.
  - 아마도.. console.log 로 확인할 때를 이야기 하는 것 같다.
  - const num = {a : 1}; typeof num.a; // number 로 리턴된다.

# 메서드

- 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다.
- 메서드를 function() 으로 선언했다면 코드블록 내부에서 사용되는 this 는 객체를 가리킨다.
- ex) const circle = {radius: 5, getDiameter : function () { return 2 \* this.radius; // this 는 circle 를 가리킨다.}}

# 프로퍼티 접근

- 프로퍼티에 접근하는 방법은 두가지다.
  - ex) const a = {b : { c : { d : 1 }}};
    - a.b.c.d; // 1
    - a["b"]["c"]["d"]; // 1
- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined 를 반환한다.

  - 초반에 실무에서 많이 실수하는 상황이 나온다.
  - ReferenceError 가 발생하지 않는다.

- p.132 페이지의 예제와 글은 한번씩 읽어보는 바를 추천한다.
  - 이 부분은 요약 정리라기보다는,, 받아쓰기가 되어야 할 것 같다.
  - node.js 와 브라우저 엔진(v8) 에서 식별하는 방식에 관한 설명이 내포되어 있다.

## 프로퍼티 수정

- 내용이 변경되더라도 주소값이 변경되는 것이 아니기 때문에 const 로 선언해도 재할당이 가능하다.
- 만약 명시적으로 객체 타입 변수의 주소 값을 변경(재할당)해야 한다면 let을 사용해야 한다.

# 프로퍼티 갱신

- 존재하는 프로퍼티에 값을 할당하면 다시 할당된 값으로 갱신된다.

# 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.

# 프로퍼티 삭제

- delete 연산자는 객체의 프로퍼티를 삭제한다.
- delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이여야 한다.
- 존재하지 않는 프로퍼티를 삭제하면 에러없이 무시된다.

# ES6에서 추가된 객체 리터럴의 확장기능

- ES6는 혁명이다.

1. 프로퍼티 축약 표현

- ex) let x = 1, y = 2; const obj = {x,y}; console.log(obj); // {x:1, y:2}

2. 계산된 프로퍼티 이름

- ex) const prefix = "prop"; let i = 0; const obj = { [`${prefix}-${++i}`] : i, [`${prefix}-${++i}`] : i, [`${prefix}-${++i}`] : i };
  - console.log(obj); // {prop-1:1, prop-2:2, prop-3:3}

3. 메서드 축약 표현

- ex) const obj = {name : "Kim", sayHi() {console.log(`Hi! ${name}`)}}; obj.sayHi(); // Hi! Kim
- 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다.
- 26.2에서 자세히
