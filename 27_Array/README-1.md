27.1~27.8
# 배열
## 27.1 배열이란?
- 여러 개의 값을 순차적으로 나열한 자료구조
- 사용 빈도가 매우 높은 가장 기본적인 자료구조
- js는 배열을 다루기 위한 유용한 메서드를 다수 제공.

```
const arr = ['apple', 'banana', 'orange'];
```

- 배열이 갖고 있는 값 : `요소`
- js 모든 값은 배열의 요소가 될 수 있다. 즉, 원시값은 물론 객체, 함수, 배열 등 js값으로 인정하는 모든 것은 배열의 요소가 될 수 있다.

- 인덱스 : 배열의 요소는 배열에서 자신의 위치를 나타내는 0 이상의 정수
- 요소의 개수 : length 프로퍼티가 존재함
```
arr[0]// 'apple'
arr[1]// 'banana'
arr[2]// 'orange'
arr.length // 3
```

- 요소 접근 방법 : 배열은 인덱스와 length 프로퍼티를 갖기 때문에 for문을 통해 접근 가능

- `js에 배열이라는 타입은 존재하지 않는다. 배열은 객체 타입이다.`
```
typeof arr //object
```
배열은 배열 리터럴, Array 생성자 함수, Array.of, Array.from메서드로 생성할 수 있다. 배열의 생성자 함수는 Array이며, 배열의 프로토타입 객체는 Array.prototype이다. Array.prototype은 배열을 위한 빌트인 메서드를 제공한다.

```
const arr = [1,2,3];

arr.constructor === Array // true
Object.getPrototypeOf(arr) === Array.prototype
```
배열은 객체지만 일반 객체와 구별되는 독특한 특징이 있음

- 일반객체와 배열을 구분하는 가장 명확한 차이는 "값의 순서"와 "length 프로퍼티"다. 인덱스로 표현되는 값의 순서와 length 프로퍼티를 갖는 배열은 반복문을 통해 순차적으로 값에 접근하기 적합한 자료구조.
```
const arr = [1,2,3];
//반복문의 자료구조를 순서대로 순환하기 위해서는 자료구조의 요소에 순서대로 순회하기 위해서는 자료구조의 요소에 순서대로 접근할 수 있어야 하며
// 자료구조의 길이를 알 수 있어야 한다.

for(let i = 0; i < arr.length; i++){
    console.log(arr[i]); //1,2,3
}
```
- 처음부터 순차적으로 요소 접근 가능
- 마지막부터 역순으로 요소 접근가능
- 특정 위치부터 순차적으로 요소 접근 가능
- 인덱스, length프로퍼티를 갖기 떄문에 가능한 것


## 27.2 자바스크립트 배열은 배열이 아니다.
- 자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속으로 나열된 자료구조를 말한다. 즉 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있따. 이러한 배열을 밀집 배열이라고 한다.

- 이처럼 일반적은 의미의 배열은 각 요소가 동일한 데이터 크기를 가지며, 빈틈없이 연속적으로 이어져 있으므로 다음과 같이 인덱스를 통해 단 한번의 연산으로 임의의 요소에 접근(임의 접근, 시간복잡도 O(1))할 수 있다. 이는 매우 효율적이며 고속으로 동작.
- 선형검색
배열에 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점 존재

- js 배열은 지금까지 살펴본 자료구조에서 말하는 일반적인 배열과는 다름.
- 메모리공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다.
- 배열의 요소가 연속적으로 이어져 있지 않은 배열을 희소 배열이라 한다.
- `js의 배열은 일반적인 배열을 흉내 낸 특수 객체이다`

- 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며, length 프로퍼티를 갖는 특수한 객체이다.
- js 배열의 요소는 사실 프로퍼티 값이다.
- js 에서 사용할 수 있는 모든 값은 객체의 프로퍼티 값이 될 수 있으므로 어떤 타입의 값이라도 배열의 요소가 될 수 있음
```
const arr = [
    'string',
    10,
    true,
    null,
    undefined,
    Nan,
    Infinity,
    [ ],
    { },
    function() {}
];
```

## 27.3 length 프로퍼티와 희소 배열
- length의 프로퍼티 값은 빈 배열이면 0, 빈 배열이 아니면 가장 큰 인덱스의 1을 더한 것과 같음
```
[].length//0
[1,2,3].length//3
```


- 일반적 배열의 length는 배열 요소의 개수, 배열길이와 언제나 일치함
- 하지만 희소 배열은 length와 배열 요소의 개수가 일치하지 않음 희소 배열은 실제 요소개수보다 언제나 큼
- 권장x, 의도적으로 만들일도 없음, 성능에 좋지 않음.
- 같은타입의 요소를 연속적으로 위치시키는 것이 최선


## 27.4 배열 생성
### 27.4.1 배열 리터럴
다양한 생성방식이 있다. 리터럴 사용이 가장 간편하고 일반적임.

```
const arr = [1,2,3];
console.log(arr.length);//3
```

### 27.4.2 Array 생성자 함수
- Object 생성자 함수를 통해 객체를 생성하듯 Array 생성자 함수를 통해 배열 생성
인수 개수에 따라 다르게 동작

```
const arr = new Array(10);

console.log(arr);//[empty *10]
console.log(arr.length);//10
```
- 이 때 생성된 배열은 희소배열이다. length 프로퍼티 값은 0이 아니지만 실제로 배열의 요소는 존재하지 않는다.
* 배열은 최대 요소를 4,294,967,295(42억개) 가질 수 있다. 이를 벗어나면 RangeError가 발생.

new Array(); // [] == arr = [];//인수 없음 - 빈배열 생성
new Array(1,2,3); //인수 2개이상 - 요소를 갖는 배열생성
new Array({});//숫자아닌 인수1개 - 인수를 요소로 갖는 배열 생성

###  27.4.3 Array.of
- 전달된 인수를 요소로 갖는 배열 생성.
- Array생성자함수와 다르게 전달된 인수가 1개이고 숫자여도 인수를 요소로 갖는 배열 생성.
```
Array.of(1);//[1]
Array.of(1,2,3);[1,2,3];
Array.of('string');//['string']
```
### 27.4.4 Array.from
- 유사배열객체 또는 이터러블객체를 인수로하는 배열로 변환하여 반환.
```
Array.from([{length : 2, 0:'a', 1: 'b'}])// ['a','b']

Array.from('hello');['h','e','l','l','o']
```
- 두번째 인수로 전달한 콜백 함수를 통해 값을만들면서 요소를 채울 수 있음.
- 첫번째 인수에 의해 생성된 배열 요소값과 인덱스를 순차적으로 전달하면서 호출하고, 콜백 함수 반환값으로 구성된 배열을 반환한다.
```
Array.from({length: 3});//[undefined,undefined,undefined]
Array.from({length: 3}, (_,i)=>i);//[0,1,2]
```
* 유사배열객체 : 인덱스로 프로퍼티 값에 접근 가능, length프로퍼티를 갖는 객체. for문으로 순회도 가능.
* 이터러블 객체 : Symbol.iterator메서드를 구현해 for...of문으로 순회가능

## 27.5 배열 요소의 참조
- 대괄호 표기법. 대괄호 안에는 인덱스 표시. 정수로 평가되는 표현식이라면 인덱스 대신 사용가능. 객체 프로퍼티 키와 같은 역할
- 존재하지 않는 요소에 접근하면 undefined가 반환. 희소배열도 동일
```
const arr = [1,2];
console.log(arr[0]);
```

## 27.6 배열 요소의 추가와 갱신
- 요소를 동적으로 추가 가능. 존재하지 않는 인덱스를 사용해 값을 할당. length값은 자동 갱신.
- 이미 존재하는 요소에 값을 재할당 하면 요소값 갱신.

```
const arr = [0];

arr[1] = 1;
console.log(arr); // [0,1]
console.log(arr.length);//2
```


## 27.7 배열 요소의 삭제
- delete연산자 사용.
- 아래 예시는 프로퍼티엔 영향을 주지 않으며 희소배열이 되기때문에 delete 연산자는 사용 자제
```
const arr = [1,2,3];
delete arr[1];
console.log(arr); //[1,empty,3]
```
- Array.prototype.splice 메서드를 사용
```
const arr = [1,2,3];
arr.splice(1,1);
console.log(arr); //[1,3]
```



