# 6장 데이터 타입


|      | 데이터 타입 | 설명                                       |
| ------ | ------------- | -------------------------------------------- |
| 원시 | 숫자 타입   | 실수 구분없이 하나의                       |
|      | 문자열 타입 | 문자열                                     |
|      | Boolean     | 논리적 참/거짓만 존재                      |
|      | undefined   | var 타입 변수에 암묵적으로 할당되는 값     |
|      | null        | 값이 없다는 것을 의도적으로 명시할 때 사용 |
|      | Symbol      | ES6에서 추가된 7번째 타입                  |
| 객체 |             | 객체, 함수, 배열 등                        |

## 숫자 타입

- JavaScript는 모든 수를 실수로 처리
- 정수로 표시된다해소 사실은 실수
- 숫자 타입은 세 가지 특별한 값
  - Infinity: 양의 무한대
  - -Infinity: 음의 무한대
  - NaN: 산술 연산 불가

## 문자열 타입

- 작은 따욤표(''), 큰따옴표(""), 또는 백틱(``)으로 텍스트를 감쌈
- 키워드나 식별자 같은 토큰과 구분하기 위해서

## 템플릿 리터럴

- ES6 추가된 새로운 몬자열 표기법
- 기능
  - 멀티라인 문자열
    - 줄바꿈 허요, 모든 공백도 그대로 적용
  - 표현식 삽입
    - `${}`으로 표현식을 감쌈
    - 표현식의 평가 결과가 문자열이 아니더라도 문자열로 강제 변환되어 삽입
  - 태그드 템플릿
- 백틱(``)을 사용해 표현

## 불리언 타입

- 논리적 참, 거짓을 나태내는 true/false

## undefined

- undefined의 값은 undefined가 유일
- var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화
- 개발자가 의도적으로 할당한 값이 아닌 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값
  - 그러므로 undefined를 개발자가 변수에 할당하면 혼란을 줄 수 있으므로 권장하지 않음
  - 개발자가 의도적으로 값이 없음을 명시할 때는 null을 할당

## null

- null 타입의 값은 null이 유일
- 변수에 값이 없다는 것을 의도적으로 명시
- 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미
- 자바스크립트 엔진은 가비지 콜렉션을 수행

## 심벌 타입

- ES6에서 추가된 변경 불가능한 원시 타입 값
- 유일 무이한 값
- 주로 이름이 충동할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용

## 객체 타입

- 11장에서 자세히
- 자바스크립트를 이루고 있는 거의 모든 것이 객체

## 데이터 타입의 필요성

- ### 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- ### 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- ### 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 동적 타이핑

### 동적 타입 언어와 정적 타입 언어

- 정적 타입언어는
  - 변수를 선언할 때 변수에 할당할 수 있는 데이터 타입을 사전에 선언
  - 컴파일 시점에 타입 체크
- 동적 타입 언어
  - 할당에 의해 타입이 결정
  - 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음, 동적 타이핑

### 동적 타입 언어와 변수

#### 모든 소프트웨어 아키텍처에는 트레이드 오프가 존재하며, 모든 애플리케이션에 적합한 은 탄환은 없듯이 동적 타입 언어 또한 구조적인 단점이 있다.

- 자바스크립트 엔진에 의해 암묵적으로 타입이 자동적으로 변환되기도 함
- 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어짐
- 변수 사용 시 주의사항
  - 제한적 사용
    - 재할당에 의해 언제든지 변경 가능
    - 개수가 많으면 오류 발생 확률이 높아짐
  - 스코프를 최대한 좁게하여 부작용을 억제
    - 13장 스코프 자세히
  - 전역 변수 최대한 사용하지 않도록
    - 어디서든 참조/변경이 가능
    - 복잡성 증가 및 흐름 추적 및 디버깅이 어려움
    - 14장 전역 변수의 문제점
  - 변수보다는 상수를 사용하여 값의 변경을 억제
    - 15.3 const 키워드
  - 의미를 파악할 수 있도록 네이밍
    - 유효 범위가 넓을수록 명확한 이름을 명명
    - 의도 및 협업과 생산성 향상에 도움
